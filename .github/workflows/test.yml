name: GitHub Actions Test
on: [push]
jobs:
  alpine-faccessto2-test:
    runs-on: ubuntu-latest
    container: alpine:3.14
    steps:
      - run: apk --no-cache add gcc libc-dev
      - run: printf '#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <sys/syscall.h>\nint main(){int ret = syscall(SYS_faccessat2, 0, "/",  R_OK, AT_EACCESS); printf("ret = %%d,%%d\\n", ret, errno);}' > foo.c
      - run: gcc foo.c
      - run: ./a.out
  foo:
    runs-on: ubuntu-latest
    steps:
      - run: docker info
      - run: pwd; ls -la
      - name: Check out repository code
        uses: actions/checkout@v2
        with:
          submodules: true
      - run: pwd; ls -la
      - name: Cache Source Code (not a great example, who cares)
        uses: actions/cache@v2
        env:
          cache-name: cache-source-code
        with:
          key: build-${{ env.cache-name }}-${{ runner.os }}
          restore-keys: |
            build-${{ env.cache-name }}-
          path: |
            ~/work
      - run: touch foobar; ls -la
      - run: docker buildx ls

      # Use this if you want to do it the HARD way
      # https://evilmartians.com/chronicles/build-images-on-github-actions-with-docker-layer-caching

      - run: docker buildx create --use
      - name: Cache Docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.branch }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      - run: docker buildx create --name ga_builder --use
      # - run: docker build -t foobar .
      - run: |
          docker buildx build --cache-from=type=local,src=/tmp/.buildx-cache \
                              --cache-to=type=local,dest=/tmp/.buildx-cache-new \
                              -t foobar -o type=docker .

      - run: docker buildx rm ga_builder
        # This means only what was built in this ci job is kept in the cache,
        # keeping the cache as small as possible (GitHub has a 5GB limit)
      - name: Move cache
        run: |
          mv /tmp/.buildx-cache /tmp/.buildx-cache-old
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      - run: docker run --rm foobar
      - run: |
          docker run -i --rm foobar
      - run: |
          script -q /dev/null -c "docker run -it --rm foobar"
  # bar:
  #   runs-on: ubuntu-latest
  #   needs: foo
  #   steps:
  #     - run: echo "This shows that not even the docker cache is shared between jobs"
  #     - run: |
  #         ! docker run --rm foobar
  #     - name: Cache Source Code (not a great example, who cares)
  #       uses: actions/cache@v2
  #       env:
  #         cache-name: cache-source-code
  #       with:
  #         key: build-${{ env.cache-name }}-${{ runner.os }}
  #         restore-keys: |
  #           build-${{ env.cache-name }}-
  #         path: |
  #           ~/work
  #     - run: pwd; ls -la

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v1

  #     - name: Cache Docker layers
  #       uses: actions/cache@v2
  #       with:
  #         path: /tmp/.buildx-cache
  #         key: ${{ runner.os }}-buildx-${{ github.branch }}
  #         restore-keys: |
  #           ${{ runner.os }}-buildx-
  #     - name: Build and push
  #       uses: docker/build-push-action@v2
  #       with:
  #         context: .
  #         push: false
  #         tags: foobar
  #         cache-from: type=local,src=/tmp/.buildx-cache
  #         cache-to: type=local,dest=/tmp/.buildx-cache-new
  #     - name: Move cache
  #       run: |
  #         rm -rf /tmp/.buildx-cache
  #         mv /tmp/.buildx-cache-new /tmp/.buildx-cache
